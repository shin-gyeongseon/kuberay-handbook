# 2.3 Ray Runtime 핵심 서비스

Ray가 분산 실행을 효과적으로 수행할 수 있는 이유는 내부에 잘 설계된 런타임 서비스들이 있기 때문입니다. 이 장에서는 Ray 클러스터 내부에서 지속적으로 작동하며, 작업 분산, 상태 관리, 데이터 전파에 중요한 역할을 수행하는 **핵심 서비스들(GCS, Object Store, Scheduler, Worker Process)**에 대해 알아봅니다.

## GCS (Global Control Store / Global Control Service)

GCS는 Ray의 **중앙 메타데이터 저장소이자 제어 서비스**입니다. 클러스터 내에서 발생하는 다양한 상태 정보를 관리합니다.

- Actor와 Task의 생성 및 상태 추적  
- 노드, 자원 사용량, 애플리케이션 정보 관리  
- Ray 1.11부터는 **내부 구현된 키-밸류 스토어와 gRPC 기반 pub/sub**를 기본으로 사용  
- 필요 시에는 외부 Redis를 고가용성 HA 백엔드로 선택적으로 연결할 수 있음

즉, GCS는 클러스터의 **두뇌 역할**을 하며, Redis는 1.11 이전까지 기본 백엔드였지만 이후 버전부터는 내부 서비스 구조로 전환되었습니다. 외부 Redis는 HA나 복구 용도로만 사용됩니다.

## Object Store

Object Store는 Ray의 **데이터 공유 메커니즘**입니다. 클러스터 내 모든 노드는 이 공유 메모리를 통해 데이터를 주고받습니다.

- Ray Task나 Actor가 반환하는 객체는 Object Store에 저장됨
- 서로 다른 노드 간 대용량 데이터를 네트워크 없이 빠르게 전달 가능
- Zero-copy 방식으로 메모리 효율성 확보

즉, Object Store는 분산된 작업들이 **데이터 병목 없이 빠르게 협력**할 수 있게 해줍니다.

## Scheduler

Ray Scheduler는 작업(Task/Actor)을 어떤 노드에 배치할지 결정하는 **중앙 스케줄러**입니다.

- 자원 정보(CPU, GPU 등)와 Task 요구사항을 바탕으로 실행 위치 결정
- GCS와 협력하여 Actor의 재시작, 위치 복원 등도 관리
- 기본적으로 Head Node에서 실행되며, 큰 클러스터에선 분산 스케줄링도 지원

효율적인 자원 배분과 빠른 작업 시작을 위해 Scheduler는 **클러스터 전체의 상황을 실시간으로 파악**합니다.

## Worker Processes

Worker는 실제로 Task나 Actor를 실행하는 **작업 실행 엔진**입니다.

- 각 Worker는 Python, Java 등으로 구동되는 독립 프로세스
- Raylet(Node 에이전트)로부터 작업 지시를 받아 실행
- 여러 Worker가 한 노드에서 병렬로 작동 가능

즉, 사용자가 정의한 함수나 클래스를 실제로 수행하는 주체는 이 Worker이며, **Ray의 실행 단위 중 가장 말단에 있는 실행자**입니다.

---

이러한 Runtime 구성 요소들은 서로 유기적으로 연결되어 Ray의 분산 실행 환경을 구성합니다. 각 컴포넌트가 담당하는 역할을 이해하면, 클러스터 내부에서 어떤 일이 일어나고 있는지를 보다 명확하게 파악할 수 있습니다.
